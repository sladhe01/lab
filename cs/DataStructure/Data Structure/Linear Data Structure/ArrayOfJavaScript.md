## 일반적인 배열

일반적으로 배열이라는 개념은 동일한 크기의 메모리 공간이 빈틈 없이 연속적으로 나열된 자료 구조를 뜻한다.
즉, 배열의 요소는 하나의 타입으로 통일되어 있으며 연속적으로 인접해 있다. 이러한 배열을 dense array(밀집 배열)라고 한다.
이렇게 배열의 요소는 동일한 크기를 가지며 빈틈없이 연속적으로 이어져 있기 때문에 인덱스를 통해 단 한번의 연산으로 시간 복잡도 O(1)의 임의 접근이 가능하다.

> ex. 메모리 주소가 1000에서 시작하고 각 요소의 크기가 8byte인 배열의 경우
> - 인덱스가 0인 요소의 메모리 주소 : 1000 + 0\*8 = 1000
> - 인덱스가 0인 요소의 메모리 주소 : 1000 + 1\*8 = 1008
> 
> 이처럼 배열은 인덱스를 톡해 효율적으로 요소에 접근할 수 있다. 하지만 정렬되지 않은 배열에서 특정한 값을 탐색하는 경우에는 모든 배열 요소를 처음부터 해당 값을 발견할 때까지 차례대로 시간복잡도 O(n)의 linear serach(선형 탐색)을 해야한다.

또한 배열에 요소를 삽입하거나 삭제하는 경우 배열의 요소를 연속적으로 유지하기 위해 뒷 요소들을 한칸씩 이동시켜야 하기 때문에 시간복잡도O(n)을 가진다.

## JavaScript의 배열

하지만 JavaScript의 배열은 위에서 언급한 배열과 다르다. 배열의 요소를 위한 각각의 메모리 공간이 동일한 크기가 아니어도 되며 연속적으로 이어져 있지 않을 수도 있다. 이러한 배열의 요소가 연속적으로 이어져 있지 않은 배열을 희소 배열(sparse array)라고 한다.
이처럼 JavaScript의 배열은 엄밀히 말해서 배열이 아니라 배열을 흉내낸 특수한 객체라고 할 수 있다.

JavaScript의 배열은 인덱스를 프로퍼티 키로 갖고 있으며 length라는 프로퍼티를 갖는 특수한 객체이다. 여기서 배열의 요소는 사실 프로퍼티 값이다. 그래서 JavaScript의 다양한 유형의 값이 배열의 요소로 사용될 수 있는 것이다.

## 비교

일반적인 배열은 인덱스로 배열 요소에 빠르게 접근할 수 있지만 특정 요소를 탐색하거나 요소를 삽입 또는 삭제하는 경우에는 효율적이지 않다.
JavaScript의 배열은 해시 테이블로 구현된 객체이므로 인덱스로 배열 요소에 접근하는 경우 일반적인 배열보다 성능적으로 느리다. 하지만 특정 요소를 탐색하거나 요소를 삽입 또는 삭제하는 경우에는 일반적인 배열보다 성능적으로 빠르다.
JavaScript 엔진은 위와 같은 구조적 단점을 보완하고자 일반 객체와 구별하여 최적화하여 구현했다.
아래와 같이 배열의 성능이 일반 객체에 비해 빠른 것을 볼 수 있다.
```js
const arr = [];
console.time('Array Performance Test');
for (let i = 0; i < 10000000; i++) {
	arr[i] = i;
}
console.timeEnd('Array Performance Test');

const obj = {};
console.time('Object Performance Test');
for (let i=0; i < 10000000; i++) {
	obj[i] = i;
}
console.timeEnd('Object Performance Test');
```